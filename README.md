# Post-Quantum Group Chat using Authenticated Group Key Establishment

This repository contains the code for the client of a post-quantum, authenticated group chat application.

It uses Kyber-GAKE for secure, quantum-resistant group key establishment among cluster members and leaders. It also offers the possibility of executing parts of the protocol through a QKD system.

## Table of Contents

1. [Running the Application](#running-the-application)

   1. [Configuration and Keys](#configuration-and-keys)
   2. [Running Locally (Linux)](#running-locally-linux)
   3. [Running using Docker](#running-using-docker)
   4. [Running using Dev Containers in VS Code](#running-using-dev-containers-in-vs-code)

2. [Configuration Files Explained](#configuration-files-explained)
   1. [Cluster Member Configuration](#cluster-member-configuration)
   2. [Cluster Leader Configuration](#cluster-leader-configuration)
3. [Mock ETSI QKD API Server](#mock-etsi-qkd-api-server)

## Running the application

To run the application, you first need to prepare the configuration files.

### Configuration and Keys

Before running the application, you need to set up the configuration files for cluster members and leaders.

You can use the `make config` command to interactively generate a complete working configuration. This will use Kyber KEM everywhere. You can change that later as you wish.

For generating the keys (if you want to do it manually or you want to simulate QKD in the cluster/between leaders), you can use:

- `make gen_kem n=X` - for generating X Kyber KEM keypairs
- `make gen_ss` - for generating the shared secret to simulate QKD in the cluster
- `make gen_2ake` - for generating the 2-AKE temporary key to simulate QKD between two leaders

### Running locally (Linux)

The prerequisites for building the application are:

```
openssl libssl-dev make gcc curl go
```

After installing the dependencies, you can use:

```
make m
```

to build the cluster member binary (`member_pqgch`) and:

```
make l
```

to build the cluster leader binary (`leader_pqgch`).

You also need to have the routing server started before running the application. The routing server is located at [this repository](https://github.com/FEI-PQGCH/pqgch-router).

Then, you can start the cluster member or leader by running `./binary_name -config path/to/config`.

> **_IMPORTANT:_** Make sure you are in the right directory where the configuration is located. Also, make sure that the paths in the configuration refer to the key files and are in the right relative path.

### Running using Docker

Instead of locally installing the dependencies, you can use Docker. In the root directory of the project, run:

```bash
docker build --tag pqgch:latest .devcontainer
```

Then start the container:

```bash
docker run -dit --name pqgch-instance -v $(pwd):/workspace pqgch:latest
```

Then you can connect to the container with multiple shells using:

```bash
docker exec -it pqgch-instance bash
```

Then you can proceed by running the application as explained in [Running locally (Linux)](#running-locally-linux)

### Running using Dev Containers in VS Code

For a simpler setup, you can use VS Code's extension for Dev Containers, which will set up a Docker image containing 20.04 Ubuntu and all required dependencies for development and testing. The files required for this are located in the `.devcontainer` folder.

Use for example the following tutorial for this: [Dev Containers Tutorial](https://code.visualstudio.com/docs/devcontainers/tutorial).

Afterwards, connect to the container using multiple shells and proceed by running programs as explained in [Running locally (Linux)](#running-locally-linux)

## Configuration Files Explained

This section explains the format and contents of the configuration files. These are plain JSON files.

### Cluster Member Configuration:

Here by _cluster_ we mean the cluster **this** cluster member belongs to.

- `server` - the IP address of the routing server
- `name` - the name of this user for display
- `clusterID` - the ID of the cluster
- `cluster`
  - `memberID` - the ID of this member within the cluster
  - `nMembers` - the number of members (including leader) of this cluster
  - `publicKeys` - the path to the file containing the public keys of all of the members of the cluster
  - `secretKey` - the path to the file containing this cluster member's base64 encoded Kyber KEM secret key

> **_NOTE:_** If you are using QKD in the cluster, you should not speficy the `publicKeys` and `secretKey` properties. Instead, you need to specify the `crypto` property containing either the path (starting with `path `) to the file containing the cluster shared secret (for example as generated by `make gen_ss`), or an URL (starting with `url `) to the ETSI API server.

Here are some examples:

- Cluster member using Kyber KEM for intra-cluster GAKE:

```javascript
{
  "server": "localhost:9000",
  "name": "Alice",
  "clusterID": 0,
  "cluster": {
    "memberID": 0,
    "nMembers": 4,
    "publicKeys": "cluster_public_keys.json",
    "secretKey": "secret.json"
  }
}
```

- Cluster member using QKD through a file:

```javascript
{
  "server": "localhost:9000",
  "name": "Alice",
  "clusterID": 1,
  "cluster": {
    "memberID": 0,
    "nMembers": 2,
    "crypto": "path key_file.json" // for example as generated by `make gen_ss`
  }
}
```

- Cluster member using QKD through ETSI API (using the mock ETSI server you can start with `make mock`):

```javascript
{
  "server": "localhost:9000",
  "name": "Alice",
  "clusterID": 1,
  "cluster": {
    "memberID": 0,
    "nMembers": 2,
    "crypto": "url http://localhost:8080/etsi/SAE_ID"
  }
}
```

### Cluster Leader Configuration:

- `server` - the IP address of the routing server
- `name` - the name of this user for display
- `clusterID` - the ID of the cluster
- `cluster`
  - `memberID` - the ID of this leader within the cluster
  - `nMembers` - the number of members (including leader) of this cluster
  - `publicKeys` - the path to the file containing the public keys of all of the members of the cluster
  - `secretKey` - the path to the file containing this leader's base64 encoded Kyber KEM secret key for the cluster part of the protocol
- `leaders`
  - `nClusters` - the number of clusters in this application configuration
  - `leftCrypto` – left neighbor crypto info (see NOTE)
  - `rightCrypto` – right neighbor crypto info (see NOTE)
  - `secretKey` - the path to the file containing this leader's base64 encoded Kyber KEM secret key

> **_NOTE:_** The `leftCrypto` and `rightCrypto` properties can be one of the following:
>
> - a path to a file containing a base64 encoded Kyber KEM public key of the corresponding neighbor (as generated by `make gen_kem`)
> - an URL of an ETSI QKD API server. In this case the string has to begin with `url`, followed by a single space and then the URL itself (for example `url http://localhost:8080/etsi/`)
> - a path to a file containing a 32 byte secret key as base64 encoded string, as generated by `make gen_2ake`. In this case the string has to begin with `path`, followed by a single space and then the path of the file on the local file system (for example `path ../.keys/key1.json`)

> **_IMPORTANT:_** It is important for the cluster leaders' `leftCrypto` and `rightCrypto` properties to match up. So as an example using the Kyber KEM public keys, if cluster leader 1 has as its right neighbor cluster leader 2, the cluster leader's 1 `rightCrypto` property contains the public key of cluster leader 2, and cluster leader's 2 `leftCrypto` property contains the public key of cluster leader 1.

Here are some examples:

- Cluster leader using Kyber KEM both for intra-cluster GAKE and extra-cluster GAKE:

```javascript
{
  "server": "localhost:9000",
  "name": "Leader1",
  "clusterID": 0,
  "cluster": {
    "memberID": 3,
    "nMembers": 4,
    "publicKeys": "cluster_public_keys.json",
    "secretKey": "secret.json"
  },
  "leaders": {
    "nClusters": 3,
    "leftCrypto": "left_pk.json",
    "rightCrypto": "right_pk.json",
    "secretKey": "secret_leader.json"
  }
}
```

- Cluster leader using QKD for intra-cluster GAKE and for 2-AKE with the left neighbor, Kyber KEM for 2-AKE with the right neighbor:

```javascript
{
  "server": "localhost:9000",
  "name": "Leader1",
  "clusterID": 0,
  "cluster": {
    "memberID": 3,
    "nMembers": 4,
    "crypto": "url http://localhost:8080/etsi/SAE_ID" // you can combine the methods as you wish
  },
  "leaders": {
    "nClusters": 3,
    "leftCrypto": "path key_file.json", // for example as generated by `make gen_2ake`
    "rightCrypto": "right_pk.json",
    "secretKey": "secret_leader.json"
  }
}
```

## Mock ETSI QKD API server

The project contains a mock ETSI QKD API server. It is a simple HTTP server providing the `Get Keys` and `Get Keys with IDs` endpoints from the [ETSI standard documentation](https://www.etsi.org/deliver/etsi_gs/QKD/001_099/014/01.01.01_60/gs_QKD014v010101p.pdf).

You can start it by running `make mock`.

You can use the following CURL commands to interact with the mock QKD server:

```
curl -X GET "http://localhost:8080/etsi/DUMMY_ID/enc_keys?number=1&size=256"
```

```
curl -X GET "http://localhost:8080/etsi/DUMMY_ID/dec_keys?key_ID=d21fe47e2ecb684b95720d740de3b1d9"
```
